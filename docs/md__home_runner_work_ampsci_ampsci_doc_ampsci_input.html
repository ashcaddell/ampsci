<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ampsci: ampsci: input options</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ampsci
   </div>
   <div id="projectbrief">c++ program for high-precision atomic structure calculations of single-valence systems</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ampsci: input options </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>ampsci input: descriptions of file format and available options</p>
<p>[Home]</p>
<h1>basic usage</h1>
<p>The program is run with input options from the command line.</p>
<h2>Main method: input options from a text file</h2>
<ul>
<li><code>./ampsci filename</code><ul>
<li>Runs ampsci with input option specified in file "filename"</li>
<li>See below for full description of input format, and a detailed list of input options + descriptions.</li>
<li>run <code>./ampsci -h</code> to get breif instructions for input options</li>
<li>Several example input files are given in: <em>doc/examples/</em>, along with their expected output; use these to test if everything is working.</li>
</ul>
</li>
</ul>
<p>The Output is printed to screen. It's recommended to forward this to a text file. The input options and the ampsci version details are also printed, so that the program output contains all required info to exactly reproduce it. e.g.,</p>
<ul>
<li><code>./ampsci input |tee -a outout</code><ul>
<li>Runs ampsci using input options in file "input".</li>
<li>Output will both be written to screen, and appended to file "output".</li>
</ul>
</li>
</ul>
<h2>quick method (simple calculations)</h2>
<p>For very simple (Hartree-Fock only) calculations, you can run ampsci directly from the command line:</p>
<ul>
<li><code>./ampsci &lt;At&gt; &lt;Core&gt; &lt;Valence&gt;</code><ul>
<li><code>./ampsci Cs</code><ul>
<li>Runs ampsci for Cs using Hartree Fock (V^N) approximation</li>
</ul>
</li>
<li><code>./ampsci Cs [Xe] 6sd5d</code><ul>
<li>Runs ampsci for Cs using Hartree Fock with Xe-like core and valence states up to n=6 for s,p-states and n=5 for d-states</li>
</ul>
</li>
<li><code>./ampsci Cs</code><ul>
<li>Runs ampsci for Cs using Hartree Fock (V^N) approximation</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Other command-line options</h2>
<ul>
<li><code>./ampsci -v</code><ul>
<li>Prints version info (same as &ndash;version)</li>
</ul>
</li>
<li><code>./ampsci -h</code><ul>
<li>Print help info, including input options (same as &ndash;help, -?)</li>
</ul>
</li>
<li><code>./ampsci -m &lt;ModuleName&gt;</code><ul>
<li>Prints list of available Modules (same as &ndash;modules)</li>
<li>ModuleName is optional. If given, will list avaiable options for that Module</li>
</ul>
</li>
<li><code>./ampsci -o &lt;OperatorName&gt;</code><ul>
<li>Prints list of available operators (same as &ndash;operators)</li>
<li>OperatorName is optional. If given, will list avaiable options for Operator</li>
</ul>
</li>
<li><code>./ampsci -a &lt;BlockName&gt;</code><ul>
<li>Prints list of available top-level ampsci options (same as &ndash;ampsci)</li>
<li>BlockName is optional; if given will print options for given ampsci Block</li>
<li>e.g., <code>./ampsci -a Basis</code> will print all available 'Basis' options</li>
</ul>
</li>
<li><code>./ampsci -p &lt;At&gt; &lt;Isotope&gt;</code><ul>
<li>Prints periodic table with electronic+nuclear info (same as &ndash;periodicTable)</li>
<li>At and Isotope are optional. If given, will print info for given isotope</li>
<li>e.g., <code>./ampsci -p Cs</code>, <code>./ampsci -p Cs 133</code>, <code>./ampsci -p Cs all</code></li>
</ul>
</li>
<li><code>./ampsci -c</code><ul>
<li>Prints some handy physical constants (same as &ndash;constants)</li>
</ul>
</li>
</ul>
<hr  />
<h1>Input file format</h1>
<p>Input is a plain text file that consists of sets of 'Blocks' and 'Options'.</p>
<ul>
<li>Blocks are followed by curly-braces: BlockName{}</li>
<li>Options are followed by a semi-colon: OptionName = option_value;</li>
<li>Generally, each Block will have a set of Options that may be set</li>
<li>Nearly all are optional - leave them blank and a default value will be used</li>
<li>Blocks may be nested inside other Blocks</li>
<li>White-space is ignored, as are ' and " characters</li>
<li>You may use C++-style line '//' and block '/**/' comments</li>
</ul>
<p>The code is "self-documenting". At any level (i.e., in any Block or at 'global' level outside of any Block), set the option 'help;', and the code will print:</p>
<ul>
<li>a list of all available Blocks and Options at that level</li>
<li>a description of what they are for, and</li>
<li>the default value if they are left unset.</li>
</ul>
<p>For example, setting 'help' at the top-level will print a list of all available top-level Blocks:</p>
<div class="fragment"><div class="line">Atom{}         <span class="comment">// InputBlock. Which atom to run for</span></div>
<div class="line"><a class="code" href="classGrid.html">Grid</a>{}         <span class="comment">// InputBlock. Set radial grid parameters</span></div>
<div class="line">HartreeFock{}  <span class="comment">// InputBlock. Options for Solving atomic system</span></div>
<div class="line">Nucleus{}      <span class="comment">// InputBlock. Set nuclear parameters</span></div>
<div class="line">RadPot{}       <span class="comment">// InputBlock. Inlcude QED radiative potential</span></div>
<div class="line">Basis{}        <span class="comment">// InputBlock. Basis used for MBPT</span></div>
<div class="line">Spectrum{}     <span class="comment">// InputBlock. Like basis; used for sum-over-states</span></div>
<div class="line">Correlations{} <span class="comment">// InputBlock. Options for correlations</span></div>
<div class="line">ExtraPotential{} <span class="comment">// InputBlock. Include an extra potential</span></div>
<div class="line">dVpol{}        <span class="comment">// InputBlock. Approximate correlation (polarisation) potential</span></div>
<div class="line"><a class="code" href="namespaceModule.html">Module</a>::*{}    <span class="comment">// InputBlock. Run any number of modules (* -&gt; module name)</span></div>
</div><!-- fragment --><p>You can get the same output by running <code>./ampsci -a</code></p>
<p>Set 'help;' inside any of these to get full set of options of each of these, and so on. Full descriptions of each Block/Option are given in doc/ - but the self-documentation of the code will always be more up-to-date.</p>
<p>You can get the same output by running <code>./ampsci -a BlockName</code>. For example, <code>./ampsci -a Basis</code> will print all available 'Basis' options</p>
<p>The general usage of the code is to first use the main blocks to construct the atomic wavefunction and basis states, then to add as many 'Module::' blocks as required. Each module is a seperate routine that will take the calculated wavefunction and compute any desired property (e.g., matrix elements). The code is designed such that anyone can write a new Module (See <a class="el" href="md__home_runner_work_ampsci_ampsci_doc_writing_modules.html">doc/writing_modules.md</a>)</p>
<p>e.g., To calculate Cs wavefunctions at HF level with 6s, 6p, and 5d valence states, and then calculate E1 matrix elements including core polarisation (RPA):</p>
<div class="fragment"><div class="line">Atom {</div>
<div class="line">  Z = Cs;</div>
<div class="line">  <a class="code" href="namespaceFGRP_1_1Fit.html#ae69d8fcc58a4bfa39180b565db2c129f">A</a> = 133;</div>
<div class="line">}</div>
<div class="line"><a class="code" href="classGrid.html">Grid</a> { } <span class="comment">// Leave all default; can also just drop entire Block</span></div>
<div class="line">Nucleus { } <span class="comment">// Default values set according to isotope</span></div>
<div class="line">HartreeFock {</div>
<div class="line">  core = [Xe];</div>
<div class="line">  valence = 6sp5d;</div>
<div class="line">}</div>
<div class="line"><a class="code" href="namespaceModule.html#aad4d284d8f72582faa35e991c685c9b5">Module::matrixElements</a> {</div>
<div class="line">  <span class="keyword">operator</span> = E1;</div>
<div class="line">  rpa = <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1>Auto-documentation</h1>
<ul>
<li>This document may go out-of-sync with the code</li>
<li>The best fail-safe way to check the available options for a given input block is to use the code itself.</li>
<li>Do this by adding a blank 'help' option to the input file:</li>
<li>The code will then print a list of all available options, and (usually) an explanation for them</li>
</ul>
<p>blockname { help; }</p>
<p>You can also access most of the self-documenation directly from the command-line:</p>
<ul>
<li><code>./ampsci -h</code><ul>
<li>Print help info, including input options (same as &ndash;help, -?)</li>
</ul>
</li>
<li><code>./ampsci -m &lt;ModuleName&gt;</code><ul>
<li>Prints list of available Modules (same as &ndash;modules)</li>
<li>ModuleName is optional. If given, will list avaiable options for that Module</li>
</ul>
</li>
<li><code>./ampsci -o &lt;OperatorName&gt;</code><ul>
<li>Prints list of available operators (same as &ndash;operators)</li>
<li>OperatorName is optional. If given, will list avaiable options for Operator</li>
</ul>
</li>
<li><code>./ampsci -a &lt;BlockName&gt;</code><ul>
<li>Prints list of available top-level ampsci options (same as &ndash;ampsci)</li>
<li>BlockName is optional; if given will print options for given ampsci Block</li>
<li>e.g., <code>./ampsci -a Basis</code> will print all available 'Basis' options</li>
</ul>
</li>
</ul>
<hr  />
<h1>Modules</h1>
<ul>
<li>The modules system allows the easy calculation of any atomic properties after the wavefunction has been calculated.</li>
<li>Any number of <em>modules</em> can be run by adding a &lsquo;Module::moduleName{}&rsquo; block.</li>
<li>Get a list of available modules: <code>./ampsci -m</code></li>
<li><code>./ampsci -m &lt;ModuleName&gt;</code><ul>
<li>Prints list of available Modules (same as &ndash;modules)</li>
<li>ModuleName is optional. If given, will list avaiable options for that Module</li>
</ul>
</li>
<li>See <a class="el" href="md__home_runner_work_ampsci_ampsci_doc_modules.html">doc/modules.md</a> for full details</li>
<li>The code is designed so that you can easily create your own modules. See <a class="el" href="md__home_runner_work_ampsci_ampsci_doc_writing_modules.html">doc/writing_modules.md</a> for details</li>
</ul>
<hr  />
<h1>Details for each input block</h1>
<ul>
<li>Basic details for each input block are given here.</li>
<li>It's generally better to get this info from the code (by setting the <code>help;</code> option in any given block), since that will always be up-to-date, while this document may fall out-of-date</li>
<li>You can also get this directly from the command-line:</li>
<li><code>./ampsci -a &lt;BlockName&gt;</code><ul>
<li>Prints list of available top-level ampsci options (same as &ndash;ampsci)</li>
<li>BlockName is optional; if given will print options for given ampsci Block</li>
<li>e.g., <code>./ampsci -a Basis</code> will print all available 'Basis' options</li>
</ul>
</li>
</ul>
<h2>Atom</h2>
<p>Available Atom options/blocks are:</p>
<div class="fragment"><div class="line">Atom{</div>
<div class="line">  Z; <span class="comment">// string or int (e.g., Cs equivilant to 55). Atomic number [default H]</span></div>
<div class="line">  <a class="code" href="namespaceFGRP_1_1Fit.html#ae69d8fcc58a4bfa39180b565db2c129f">A</a>; <span class="comment">// int. Atomic mass number (set A=0 to use pointlike nucleus) [default based on Z]</span></div>
<div class="line">  varAlpha2; <span class="comment">// Fractional variation of the fine-structure constant, alpha^2: d(a^2)/a_0^2. Use to enforce the non-relativistic limit (c-&gt;infinity =&gt; alpha-&gt;0), or calculate sensitivity to variation of alpha. [1.0]</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>HartreeFock</h2>
<div class="fragment"><div class="line">HartreeFock{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  Options for solving lowest-order atomic wavefunction</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  core; <span class="comment">// Core configuration. Either list entire core, or use [At] short-hand. e.g., [He] equivilant to 1s2; [Xe],6s1 equivilant to [Cs] and to 1s2,2s2,...,5p6,6s1. [blank by default]</span></div>
<div class="line">  valence; <span class="comment">// e.g., 7sp5d will include valence states up to n=7 for s and p, but n=5 for d states. Automatically excludes states in the core. [blank by default]</span></div>
<div class="line">  eps; <span class="comment">// HF convergance goal [1.0e-13]</span></div>
<div class="line">  method; <span class="comment">// HartreeFock, Hartree, KohnSham, Local [HartreeFock]</span></div>
<div class="line">  Breit; <span class="comment">// Scale for factor for Breit Hamiltonian. Usially 0.0 (no Breit) or 1.0 (full Breit), but can take any value. [0.0]</span></div>
<div class="line">  sortOutput; <span class="comment">// Sort energy tables by energy? [false]</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Nucleus</h2>
<div class="fragment"><div class="line">Nucleus{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  Options for nuclear potential (finite nuclear size). All are optional. Default is a Fermi-like nucleus, with parameters chosen according to isotope (see Atom{A;})</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  rrms; <span class="comment">// Root-mean-square charge radius, in fm [default depends on Z and A]</span></div>
<div class="line">  <a class="code" href="namespacePhysConst.html#af3948ef083a64b0a3ff75aa6e8ddf8e9">c</a>; <span class="comment">// Half-density radius, in fm (will over-ride rms) [default depends on Z and A]</span></div>
<div class="line">  t; <span class="comment">// Nuclear skin thickness, in fm [2.3]</span></div>
<div class="line">  type; <span class="comment">// Fermi, spherical, pointlike, Gaussian [Fermi]</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>Grid</h2>
<div class="fragment"><div class="line"><a class="code" href="classGrid.html">Grid</a>{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  Options for radial grid (lattice) used for integrations, solving equations and storing oritals. All relevant quantities are in units of Bohr radius (aB).</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  r0; <span class="comment">// Initial grid point, in aB [1.0e-6]</span></div>
<div class="line">  rmax; <span class="comment">// Finial grid point [120.0]</span></div>
<div class="line">  num_points; <span class="comment">// Number of grid points [2000]</span></div>
<div class="line">  type; <span class="comment">// Type of grid: loglinear, logarithmic, linear [loglinear]</span></div>
<div class="line">  b; <span class="comment">// Only used for loglinear: grid is ~ logarithmic for r&lt;b, linear for r&gt;b [rmax/3]</span></div>
<div class="line">  du; <span class="comment">// du is uniform grid step size; set this instead of num_points - will override num_points [default set by num_points]. Rarely used.</span></div>
<div class="line">}</div>
</div><!-- fragment --><h2>dVpol (effective polarisation potential)</h2>
<div class="fragment"><div class="line">Available dVpol options/blocks are:</div>
<div class="line">dVpol{</div>
<div class="line">  a_eff; <span class="comment">// scale factor for effective pol. potential [1]</span></div>
<div class="line">  r_cut; <span class="comment">// cut-off parameter [=1]</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Effective polarisation potential:</li>
<li>dV = -0.5 * a_eff / (r^4 + r_cut^4)</li>
<li>nb: Added to direct potential <em>after</em> HF for core, but <em>before</em> HF for valence</li>
</ul>
<h2>ExtraPotential (read from text file)</h2>
<div class="fragment"><div class="line">ExtraPotential{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  Option to add an extra potential (to Vnuc), before HF solved.</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  filename; <span class="comment">// Read potential from file (r v(r)) - will be interpolated [blank]</span></div>
<div class="line">  factor; <span class="comment">// potential is scaled by this value [default=1]</span></div>
<div class="line">  beforeHF; <span class="comment">// include before HF (into core states). default=false</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Reads in extra potential from text file (space separated: 'x y' format):</li>
<li>Interpolates these points onto the grid (but does NOT extrapolate, potential is assumed to be zero outside the given range)</li>
<li>Potential is multiplied by 'factor'</li>
<li>May be added before or after HF (if before: added to vnuc, if after: to vdir)</li>
</ul>
<h2>RadPot (Ginges/Flambaum QED Radiative Potential)</h2>
<div class="fragment"><div class="line">RadPot{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  QED Radiative potential will be included if this block is present</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  The following 5 are all doubles. Scale to include * potential; usually either 0.0 or 1.0, but can take any value:</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  Ueh; <span class="comment">//   Uehling (vacuum pol). [1.0]</span></div>
<div class="line">  SE_h; <span class="comment">//   self-energy high-freq electric. [1.0]</span></div>
<div class="line">  SE_l; <span class="comment">//   self-energy low-freq electric. [1.0]</span></div>
<div class="line">  SE_m; <span class="comment">//   self-energy magnetic. [1.0]</span></div>
<div class="line">  WK; <span class="comment">//   Wickman-Kroll. [0.0]</span></div>
<div class="line">  rcut; <span class="comment">// Maximum radius (au) to calculate Rad Pot for [5.0]</span></div>
<div class="line">  scale_rN; <span class="comment">// Scale factor for Nuclear size. 0 for pointlike, 1 for typical [1.0]</span></div>
<div class="line">  scale_l; <span class="comment">// List of doubles. Extra scaling factor for each l e.g., 1,0,1 =&gt; include for s and d, but not for p [1.0]</span></div>
<div class="line">  core_qed; <span class="comment">// Include rad pot into Hartree-Fock core (relaxation) [true]</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Adds QED radiative potential to Hamiltonian.</li>
<li>QED will be included if this block is present; else not</li>
<li>Will read from file if it exists (e.g., Z_uhlmw.qed)</li>
<li>Each factor (Ueh, SE_h,..) is a scale; 0 means don't include. 1 means include full potential. Any positive number is valid.</li>
<li>rcut: Only calculates potential for r &lt; rcut [for speed; rcut in au]</li>
<li>scale_rN: finite nucleus effects: rN = rN * scale_rN (=0 means pointlike)</li>
<li>scale_l: Optional input: Scaling factors for the V_rad for each l state; for higher states, uses the last given input. Input as a list of real numbers. Best explained with examples:<ul>
<li>scale_l = 1; // include QED for all states</li>
<li>scale_l = 0,1,0; //include QED for p states only</li>
<li>scale_l = 0,1; //inlcude QED for p,d,f.. but not s states.</li>
<li>don't need to be 1 or 0, can be any real number.</li>
</ul>
</li>
<li>core_qed: if true, will include QED effects into core in Hartree-Fock (relaxation). If false, will include QED only for valence states</li>
</ul>
<h2>Basis (B-spline basis for MBPT)</h2>
<ul>
<li>The 'basis' is used for summing over states in MBPT. (A second 'basis', called spectrum, may be used for summation over states in other problems)</li>
</ul>
<div class="fragment"><div class="line">Basis{</div>
<div class="line">  number; <span class="comment">// Number of splines used in expansion [0]</span></div>
<div class="line">  order; <span class="comment">// order of splines ~7-9 [7]</span></div>
<div class="line">  r0; <span class="comment">// minimum cavity radius (first internal knot) [1.0e-4]</span></div>
<div class="line">  r0_eps; <span class="comment">// Select cavity radius r0 for each l by position where |psi(r0)/psi_max| falls below r0_eps [1.0e-3]</span></div>
<div class="line">  rmax; <span class="comment">// maximum cavity radius [Grid{rmax}]</span></div>
<div class="line">  states; <span class="comment">// states to keep (e.g., 30spdf20ghi)</span></div>
<div class="line">  print; <span class="comment">// Print all spline energies (for testing) [false]</span></div>
<div class="line">  positron; <span class="comment">// Include -ve energy states [false]]</span></div>
<div class="line">  type; <span class="comment">// Derevianko (DKB) or Johnson [Derevianko]</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Constructs basis using <em>number</em> splines of order <em>order</em></li>
<li>on sub-grid (r0,rmax) [if zero, will use full grid]</li>
<li>r0_eps: Only calculate splines for r where relative core density is larger than r0_eps (updates r0 for each l). Typically ~1.0e-8. Set to zero to use r0.</li>
<li>If print = true, will print basis energies</li>
<li>positron: include negative energy states into basis</li>
<li>states: which basis states to store<ul>
<li>e.g., "7sp5df" will store s and p states up to n=7, and d and f up to n=5</li>
<li>spd will store <em>all</em> (number) states for l&lt;=2</li>
</ul>
</li>
</ul>
<h2>Correlations (Correlation potential, Sigma)</h2>
<ul>
<li>For including correlations. 'basis' must exist to calculate Sigma, but not to read Sigma in from file.</li>
</ul>
<div class="fragment"><div class="line">Correlations{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  Options for inclusion of correlations (correlation potential method). It&#39;s become a bit of a mess, and will be refactored ~soon~</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  Brueckner; <span class="comment">// Form Brueckner orbitals [false]</span></div>
<div class="line">  energyShifts; <span class="comment">// Calculate MBPT2 shift [false]</span></div>
<div class="line">  n_min_core; <span class="comment">// Minimum core n to polarise [1]</span></div>
<div class="line">  fitTo_cm; <span class="comment">// List of binding energies (in cm^-1) to scale Sigma for. Must be in same order as valence states</span></div>
<div class="line">  lambda_kappa; <span class="comment">// Scaling factors for Sigma. Must be in same order as valence states</span></div>
<div class="line">  read; <span class="comment">// Filename to read in Sigma [false=don&#39;t read]</span></div>
<div class="line">  write; <span class="comment">// Filename to write Sigma to [false=don&#39;t write]</span></div>
<div class="line">  rmin; <span class="comment">// minimum radius to calculate sigma for [1.0e-4]</span></div>
<div class="line">  rmax; <span class="comment">// maximum radius to calculate sigma for [30.0]</span></div>
<div class="line">  stride; <span class="comment">// Only calculate Sigma every &lt;stride&gt; points</span></div>
<div class="line">  each_valence; <span class="comment">// Different Sigma for each valence states? [false]</span></div>
<div class="line">  ek; <span class="comment">// Block: Explicit list of energies to solve for. e.g., ek{6s+=-0.127, 7s+=-0.552;}. Blank =&gt; HF energies</span></div>
<div class="line">  Feynman; <span class="comment">// Use Feynman method [false]</span></div>
<div class="line">  fk; <span class="comment">// List of doubles. Screening factors for effective all-order exchange. In Feynman method, used in exchange+ladder only; Goldstone, used direct also. If blank, will calculate them from scratch. []</span></div>
<div class="line">  eta; <span class="comment">// List of doubles. Hole-Particle factors. In Feynman method, used in ladder only; Goldstone, used direct also. []</span></div>
<div class="line">  screening; <span class="comment">// bool. Include Screening [false]</span></div>
<div class="line">  holeParticle; <span class="comment">// Include hole-particle interaction [false]</span></div>
<div class="line">  <a class="code" href="namespaceModule.html#a78f90f1889c6727c97a0108b37e67ee3">ladder</a>; <span class="comment">// Experimental feature. Filename for ladder diagram file (generated in the ladder Module). If blank, ladder not included. Only in Feynman. []</span></div>
<div class="line">  lmax; <span class="comment">// Maximum l used for Feynman method [6]</span></div>
<div class="line">  basis_for_Green; <span class="comment">// Use basis for Feynman Greens function [false]</span></div>
<div class="line">  basis_for_pol; <span class="comment">// Use basis for Feynman polarisation op [false]</span></div>
<div class="line">  real_omega; <span class="comment">// [worked out by default]</span></div>
<div class="line">  imag_omega; <span class="comment">// w0, wratio for Im(w) grid [0.01, 1.5]</span></div>
<div class="line">  include_G; <span class="comment">// Inlcude lower g-part into Sigma [false]</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Includes correlation corrections. note: splines must exist already</li>
<li>read/write: Read/write from/to file. Set to 'false' to calculate from scratch (and not write to file). By default, the file name is: "Atom".sig.<ul>
<li>Alternatively, put any text here to be a custom filename (e.g., read/write="Cs_new"; will read/write from/to Cs_new.sig). Don't include the '.sig' extension (uses sigf for Feynman method, sig2 for Goldstone). Grids must match exactly when reading in from a file.</li>
<li>If reading Sigma in from file, basis doesn't need to exist</li>
</ul>
</li>
<li>n_min_core: minimum core n included in the Sigma calculation; lowest states often contribute little, so this speeds up the calculations</li>
<li>energyShifts: If true, will calculate the second-order energy shifts (from scratch, according to MBPT) - compares to &lt;v|Sigma|v&gt; if it exists<ul>
<li>Note: Uses basis. If reading Sigma from disk, and no basis given, energy shifts will all be 0.0</li>
</ul>
</li>
<li>Brueckner: Construct Brueckner valence orbitals using correlation potential method (i.e., include correlations into wavefunctions and energies for valence states)</li>
<li>stride: Only calculates Sigma every nth point (Sigma is NxN matrix, so stride=4 leads to ~16x speed-up vs 1)</li>
<li>rmin/rmax: min/max points along radial Grid Sigma is calculated+stored.</li>
<li>lambda_kappa: Rescale Sigma -&gt; lambda*Sigma. One lambda for each kappa. If not given, assumed to be 1.<ul>
<li>Note: Lambda's are not written/read to file, so these must be given (if required) even when reading Sigma from disk</li>
</ul>
</li>
<li>fk: Effective screening factors; only used for 2nd-order Goldstone method<ul>
<li>Note: Included directly into Sigma</li>
<li>e.g., for Cs: fk = 0.72, 0.62, 0.83, 0.89, 0.94, 1.0;</li>
<li>If blank, will calculate these from scratch for each state (better, slower)</li>
</ul>
</li>
<li>fitTo_cm: Provide list of energies (lowest valence states for each kappa); Sigma for each kappa will be automatically re-scaled to exactly reproduce these. Give as binding energies in inverse cm! It will print the lambda_kappa's that it calculated<ul>
<li>e.g., fitTo_cm = -31406.5, -20228.2, -19674.1; will fit for the lowest s &amp; p states for Cs</li>
<li>Will over-write lambda_kappa</li>
<li>-43487.11, -28583.45, -28583.11, -12204.03, -12203.99, -6856.91, -6856.91; // Li</li>
<li>-41449.45, -24493.28, -24476.08, -12276.56, -12276.61, -6862.53, -6862.53; // Na</li>
<li>-35009.81, -22024.63, -21966.92, -13472.83, -13475.13, -6881.96, -6881.96; // K</li>
<li>-33690.81, -21111.86, -20874.265, -14335.161, -14335.607, -6898.692, -6898.718; // Rb</li>
<li>-31406.468, -20228.200, -19674.161, -16907.211, -16809.625, -6934.241, -6934.422; // Cs</li>
<li>-80686.30, -60424.74, -58733.90, -75812.45, -75011.49, -32427.68, -32202.97; // Ba+</li>
<li>-32848.87, -20611.46, -18924.87, -16619.00, -16419.23; // Fr</li>
<li>-81842.5 -60491.2, -55633.6, -69758.2, -68099.5, -32854.6, -32570.4; // Ra+</li>
</ul>
</li>
</ul>
<h2>Spectrum (B-spline basis for MBPT)</h2>
<ul>
<li>The 'Spectrum' is similar to basis, but also includes correlation corrections (if Sigma exists)</li>
<li>Useful, since we often need a small basis to compute MBPT terms, but a large basis to complete other sum-over-states calculations.</li>
</ul>
<div class="fragment"><div class="line">Spectrum{</div>
<div class="line">  <span class="comment">/*</span></div>
<div class="line"><span class="comment">  Options for &#39;spectrum&#39;, Spectrum is the same as &#39;Basis&#39;, but includes correlations. Spectrum is used for sum-over-states (while basis is used for MBPT).</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  number; <span class="comment">// Number of splines used in expansion</span></div>
<div class="line">  order; <span class="comment">// order of splines ~7-9</span></div>
<div class="line">  r0; <span class="comment">// minimum cavity radius</span></div>
<div class="line">  r0_eps; <span class="comment">// Select cavity radius r0 for each l by position where |psi(r0)/psi_max| falls below r0_eps</span></div>
<div class="line">  rmax; <span class="comment">// maximum cavity radius</span></div>
<div class="line">  states; <span class="comment">// states to keep (e.g., 30spdf20ghi)</span></div>
<div class="line">  print; <span class="comment">// Print all spline energies (for testing)</span></div>
<div class="line">  positron; <span class="comment">// Include -ve energy states (true/false)</span></div>
<div class="line">  type; <span class="comment">// Derevianko (DKB) or Johnson [Derevianko]</span></div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="anamespaceModule_html_aad4d284d8f72582faa35e991c685c9b5"><div class="ttname"><a href="namespaceModule.html#aad4d284d8f72582faa35e991c685c9b5">Module::matrixElements</a></div><div class="ttdeci">void matrixElements(const IO::InputBlock &amp;input, const Wavefunction &amp;wf)</div><div class="ttdoc">Calculates matrix elements of any tensor operator, with RPA.</div><div class="ttdef"><b>Definition:</b> matrixElements.cpp:28</div></div>
<div class="ttc" id="anamespaceFGRP_1_1Fit_html_ae69d8fcc58a4bfa39180b565db2c129f"><div class="ttname"><a href="namespaceFGRP_1_1Fit.html#ae69d8fcc58a4bfa39180b565db2c129f">FGRP::Fit::A</a></div><div class="ttdeci">double A(double Z, int l=0)</div><div class="ttdoc">Al(Z) fitting function [PRA 93, 052509 (2016)].</div><div class="ttdef"><b>Definition:</b> FGRadPot.cpp:121</div></div>
<div class="ttc" id="anamespaceModule_html"><div class="ttname"><a href="namespaceModule.html">Module</a></div><div class="ttdoc">Modules are run using calculated atomic wavefunctions.</div><div class="ttdef"><b>Definition:</b> Module_atomicKernal.cpp:12</div></div>
<div class="ttc" id="aclassGrid_html"><div class="ttname"><a href="classGrid.html">Grid</a></div><div class="ttdoc">Holds grid, including type + Jacobian (dr/du)</div><div class="ttdef"><b>Definition:</b> Grid.hpp:31</div></div>
<div class="ttc" id="anamespacePhysConst_html_af3948ef083a64b0a3ff75aa6e8ddf8e9"><div class="ttname"><a href="namespacePhysConst.html#af3948ef083a64b0a3ff75aa6e8ddf8e9">PhysConst::c</a></div><div class="ttdeci">constexpr double c</div><div class="ttdoc">speed of light in a.u. (=1/alpha)</div><div class="ttdef"><b>Definition:</b> PhysConst_constants.hpp:17</div></div>
<div class="ttc" id="anamespaceModule_html_a78f90f1889c6727c97a0108b37e67ee3"><div class="ttname"><a href="namespaceModule.html#a78f90f1889c6727c97a0108b37e67ee3">Module::ladder</a></div><div class="ttdeci">void ladder(const IO::InputBlock &amp;input, const Wavefunction &amp;wf)</div><div class="ttdoc">Module for testing ladder diagram implementation.</div><div class="ttdef"><b>Definition:</b> ladder.cpp:19</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 26 2022 05:28:38 for ampsci by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
